# Java内存模型

Java 内存模型是一种符合计算机内存模型规范的，通过屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，一种机制（规范），其目的是为了解决多线程情况下进行通信的时候存在的一些原子性，可见性以及有序性的问题。

Java内存模型规定了所有的变量都存储在主内存（此主内存在物理上仅为虚拟机的内存的一部分）中，除此之外每条线程还有自己的工作内存，我们称之为work memory，其中保存了被该线程使用的变量的主内存副本。线程对变量所有的操作都必须在工作内存中进行，不能直接操作主内存数据，同时不同线程之间无法访问对方工作内存中的变量，线程之间的传递都需要通过主内存来完成。三者关系如图所示。

![](<../.gitbook/assets/image (11).png>)

volatile为JVM中锁提供的最轻量级别的同步机制。

定义volatile属性之后特征如下：

1.此变量对所有线程可见。

2.禁止重排序优化（设置**内存屏障**）。

ps：volatile只保证可见性，在不符合上述两条规则的场景下，我们还是得通过锁，或者JUC来保障操作的原子性。

在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。**但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。**

解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？

在某些情况下，**volatile的同步机制的性能确实要优于锁**（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。

如果让volatile自己与自己比较，那可以确定一个原则：

volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，**大多数场景下volatile的总开销仍然要比锁来得更低。**我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。

### 原子性

由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的**（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）**。

如果需要一个更大范围的原子性保证，java提供了lock和unlock来满足需求，其中synchronized关键字锁对应的字节码指令为monitorenter，monitorexit。

### 可见性

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，**volatile的特殊规则保证了新值能立即同步到主内存**，以及每次使用前立即从主内存刷新。

因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

除了volatile之外，java还提供了两个关键字能够实现可见性，Synchronized和final。

同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。

final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。

### 有序性

Java程序中天然的有序性可以总结为一句话：如**果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。**前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句**是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。**

Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。
